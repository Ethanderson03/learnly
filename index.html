<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learnly - Visual Learning Tree</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useState, useMemo, useRef, useCallback } = React;

      // ============================================
      // CONSTANTS & UTILITIES
      // ============================================
      const NODE_WIDTH = 200;
      const NODE_HEIGHT = 70;
      const HORIZONTAL_GAP = 50;
      const VERTICAL_GAP = 80;
      const API_ENDPOINT = "/api/chat";
      const STORAGE_KEY_API = "learnly_api_key";
      const STORAGE_KEY_MODEL = "learnly_model";

      const MODELS = [
        { id: "claude-sonnet-4-20250514", name: "Claude Sonnet 4", description: "Best balance of speed and intelligence" },
        { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", description: "Fast and capable" },
        { id: "claude-3-5-haiku-20241022", name: "Claude 3.5 Haiku", description: "Fastest, great for quick responses" },
      ];

      const initialRootMessages = [
        {
          role: "assistant",
          text: "Welcome to Learnly. Ask any question to begin exploring. Fork conversations to dig deeper into specific concepts. Mark messages as 'foundations' when you understand them.\n\nClick the âš™ button in the sidebar to add your Anthropic API key.",
        },
      ];

      // ============================================
      // API HELPER
      // ============================================
      const sendToClaudeAPI = async (messages, apiKey, model, systemPrompt) => {
        const response = await fetch(API_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-API-Key": apiKey,
          },
          body: JSON.stringify({
            messages: messages.map(m => ({
              role: m.role === "user" ? "user" : "assistant",
              content: m.text
            })).filter(m => m.role === "user" || m.role === "assistant"),
            system: systemPrompt,
            model: model,
            max_tokens: 2048,
          }),
        });

        const data = await response.json();

        if (!data.success) {
          throw new Error(data.error || "API request failed");
        }

        return data.message;
      };

      // ============================================
      // DATA MODELS
      // ============================================
      const createNode = ({
        id,
        parentId = null,
        title,
        messages,
        status = "open",
        createdAt = Date.now(),
        health = "exploring",
        foundationMarkers = [],
        mergeHistory = [],
        expertiseLevel = null, // null = not set, 1-5 scale (novice to expert)
      }) => ({
        id,
        parentId,
        title,
        messages,
        status,
        createdAt,
        health,
        foundationMarkers,
        mergeHistory,
        expertiseLevel,
      });

      const selectionText = () => {
        const text = window.getSelection().toString();
        return text.trim();
      };

      const summarizeMessages = (messages, foundationMarkers = []) => {
        if (!messages || messages.length === 0) return "No content to merge.";

        const contentMessages = messages.filter((m) => m.role !== "system");

        // Prioritize foundation-marked messages
        const foundations = foundationMarkers
          .map(idx => contentMessages[idx])
          .filter(Boolean)
          .map(m => `â˜… ${m.text.slice(0, 150)}`);

        // Get key Q&A pairs
        const exchanges = [];
        for (let i = 0; i < contentMessages.length - 1; i++) {
          if (contentMessages[i].role === 'user' && contentMessages[i + 1].role === 'assistant') {
            exchanges.push({
              q: contentMessages[i].text.slice(0, 80),
              a: contentMessages[i + 1].text.slice(0, 150)
            });
          }
        }

        let summary = '';
        if (foundations.length > 0) {
          summary += '## Key Foundations:\n' + foundations.join('\n') + '\n\n';
        }
        if (exchanges.length > 0) {
          summary += '## Discussion:\n';
          exchanges.slice(-3).forEach(ex => {
            summary += `Q: ${ex.q}\nA: ${ex.a}\n\n`;
          });
        }

        return summary || contentMessages.slice(-4).map(m => `${m.role}: ${m.text.slice(0, 100)}`).join('\n');
      };

      const calculateHealth = (node) => {
        const contentMessages = node.messages.filter(m => m.role !== 'system');
        if (contentMessages.length === 0) return 'exploring';

        const ratio = node.foundationMarkers.length / contentMessages.length;
        if (ratio >= 0.4) return 'grounded';
        if (ratio >= 0.15) return 'exploring';
        return 'needs-review';
      };

      // Parse AI response to extract suggestions and clean text
      const parseAIResponse = (text) => {
        const suggestionsMatch = text.match(/```suggestions\s*([\s\S]*?)```/);
        let suggestions = { branches: [], quick_answers: [] };
        let cleanText = text;

        if (suggestionsMatch) {
          try {
            const parsed = JSON.parse(suggestionsMatch[1].trim());
            suggestions = {
              branches: parsed.branches || [],
              quick_answers: parsed.quick_answers || parsed.questions || [] // support both
            };
            cleanText = text.replace(/```suggestions\s*[\s\S]*?```/, '').trim();
          } catch (e) {
            console.warn('Failed to parse suggestions:', e);
          }
        }

        return { cleanText, suggestions };
      };

      // Simple markdown renderer
      const renderMarkdown = (text) => {
        if (!text) return null;

        // Split into lines and process
        const lines = text.split('\n');
        const elements = [];
        let listItems = [];
        let inList = false;

        const processInline = (line) => {
          // Bold: **text** or __text__
          line = line.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
          line = line.replace(/__(.+?)__/g, '<strong>$1</strong>');
          // Italic: *text* or _text_
          line = line.replace(/\*([^*]+)\*/g, '<em>$1</em>');
          line = line.replace(/_([^_]+)_/g, '<em>$1</em>');
          // Code: `text`
          line = line.replace(/`([^`]+)`/g, '<code>$1</code>');
          return line;
        };

        lines.forEach((line, idx) => {
          const trimmed = line.trim();

          // Bullet list item
          if (trimmed.match(/^[-*â€¢]\s+/)) {
            const content = trimmed.replace(/^[-*â€¢]\s+/, '');
            listItems.push(content);
            inList = true;
          } else {
            // Flush list if we were in one
            if (inList && listItems.length > 0) {
              elements.push(
                <ul key={`list-${idx}`} className="md-list">
                  {listItems.map((item, i) => (
                    <li key={i} dangerouslySetInnerHTML={{ __html: processInline(item) }} />
                  ))}
                </ul>
              );
              listItems = [];
              inList = false;
            }

            // Headers
            if (trimmed.startsWith('### ')) {
              elements.push(<h4 key={idx} className="md-h4">{trimmed.slice(4)}</h4>);
            } else if (trimmed.startsWith('## ')) {
              elements.push(<h3 key={idx} className="md-h3">{trimmed.slice(3)}</h3>);
            } else if (trimmed.startsWith('# ')) {
              elements.push(<h2 key={idx} className="md-h2">{trimmed.slice(2)}</h2>);
            } else if (trimmed) {
              elements.push(
                <p key={idx} dangerouslySetInnerHTML={{ __html: processInline(trimmed) }} />
              );
            }
          }
        });

        // Flush any remaining list
        if (listItems.length > 0) {
          elements.push(
            <ul key="list-final" className="md-list">
              {listItems.map((item, i) => (
                <li key={i} dangerouslySetInnerHTML={{ __html: processInline(item) }} />
              ))}
            </ul>
          );
        }

        return elements;
      };

      // ============================================
      // TREE LAYOUT CALCULATION
      // ============================================
      const calculateTreeLayout = (tree) => {
        const positions = {};

        const getSubtreeWidth = (node) => {
          if (!node.children || node.children.length === 0) {
            return NODE_WIDTH;
          }
          const childrenWidth = node.children.reduce((sum, child, idx) => {
            return sum + getSubtreeWidth(child) + (idx > 0 ? HORIZONTAL_GAP : 0);
          }, 0);
          return Math.max(NODE_WIDTH, childrenWidth);
        };

        const layoutNode = (node, x, y, depth) => {
          const subtreeWidth = getSubtreeWidth(node);
          const nodeX = x + (subtreeWidth - NODE_WIDTH) / 2;

          positions[node.id] = { x: nodeX, y, depth };

          if (node.children && node.children.length > 0) {
            let childX = x;
            node.children.forEach((child) => {
              const childWidth = getSubtreeWidth(child);
              layoutNode(child, childX, y + NODE_HEIGHT + VERTICAL_GAP, depth + 1);
              childX += childWidth + HORIZONTAL_GAP;
            });
          }
        };

        layoutNode(tree, 100, 80, 0);
        return positions;
      };

      // ============================================
      // UI COMPONENTS - Depth Meter
      // ============================================
      function DepthMeter({ currentDepth, maxDepth }) {
        const segments = 8;
        const threshold = 4;

        const getSegmentClass = (index) => {
          if (index >= currentDepth) return '';
          if (index < 2) return 'filled-green';
          if (index < 4) return 'filled-yellow';
          return 'filled-red';
        };

        return (
          <div className="depth-meter">
            <div className="meter-label">
              DEPTH [{currentDepth}/{maxDepth}]
            </div>
            <div className="meter-bar">
              {Array.from({ length: segments }, (_, i) => (
                <div
                  key={i}
                  className={`meter-segment ${getSegmentClass(i)}`}
                />
              ))}
            </div>
            {currentDepth >= threshold && (
              <div className="depth-warning terminal-glow">
                ! DEEP EXPLORATION !
              </div>
            )}
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Foundation Map
      // ============================================
      function FoundationMap({ trees, onJumpTo }) {
        const allFoundations = useMemo(() => {
          const foundations = [];

          const traverse = (node, depth = 0) => {
            if (!node) return;
            (node.foundationMarkers || []).forEach((idx) => {
              const msg = node.messages.filter(m => m.role !== 'system')[idx];
              if (msg) {
                foundations.push({
                  nodeId: node.id,
                  nodeTitle: node.title,
                  messageIndex: idx,
                  text: msg.text.slice(0, 40) + '...',
                  depth,
                });
              }
            });
            (node.children || []).forEach((child) => traverse(child, depth + 1));
          };

          (trees || []).forEach(t => traverse(t));
          return foundations;
        }, [trees]);

        if (allFoundations.length === 0) return null;

        return (
          <div className="foundation-map">
            <div className="map-header">
              FOUNDATIONS [{allFoundations.length}]
            </div>
            <div className="map-list">
              {allFoundations.map((f, i) => (
                <div
                  key={`${f.nodeId}-${f.messageIndex}`}
                  className="foundation-entry"
                  onClick={() => onJumpTo(f.nodeId)}
                >
                  <span className="foundation-marker">â˜…</span>
                  <span className="foundation-text">{f.text}</span>
                  <span className="foundation-depth">[D{f.depth}]</span>
                </div>
              ))}
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Sidebar
      // ============================================
      function Sidebar({ trees, activeId, onSelect, onNewChat, currentDepth, maxDepth, onJumpTo, onOpenSettings, hasApiKey }) {
        const renderNode = (node, depth = 0) => (
          <li key={node.id}>
            <div className="tree-branch">
              <div
                className={`tree-node ${activeId === node.id ? "active" : ""} health-${node.health || 'exploring'}`}
                onClick={() => onSelect(node.id)}
              >
                <div className="title">
                  <span className="depth-tag">[D{depth}]</span>
                  <span className="text">{node.title}</span>
                </div>
                <div className="meta">
                  {node.children?.length || 0} forks â€¢ {node.messages.length} msgs
                  {node.foundationMarkers?.length > 0 && ` â€¢ ${node.foundationMarkers.length}â˜…`}
                </div>
              </div>
            </div>
            {node.children && node.children.length > 0 && (
              <ul className="tree-children">
                {node.children.map((child) => renderNode(child, depth + 1))}
              </ul>
            )}
          </li>
        );

        return (
          <aside className="sidebar">
            <div className="sidebar-header">
              <div className="sidebar-title-row">
                <h1>Learnly</h1>
                <button
                  className={`settings-btn ${hasApiKey ? 'has-key' : ''}`}
                  onClick={onOpenSettings}
                  title="Settings"
                >
                  âš™
                </button>
              </div>
              <p className="hint">Visual learning through branching exploration</p>
              {!hasApiKey && (
                <div className="api-warning" onClick={onOpenSettings}>
                  âš  Add API key to enable AI
                </div>
              )}
              <button className="primary-btn full-width" onClick={onNewChat}>
                + New Thread
              </button>
            </div>
            <DepthMeter currentDepth={currentDepth} maxDepth={maxDepth} />
            <FoundationMap trees={trees} onJumpTo={onJumpTo} />
            <div className="tree-list-container">
              <ul className="tree-list">
                {trees.map(t => renderNode(t, 0))}
              </ul>
            </div>
          </aside>
        );
      }

      // ============================================
      // UI COMPONENTS - Message List
      // ============================================
      function MessageList({ messages, foundationMarkers = [], onToggleFoundation, nodeId, onFork, onQuickReply }) {
        const contentMessages = messages.filter(m => m.role !== 'system');

        if (!messages.length) {
          return <div className="empty">No messages yet. Ask something to begin exploring.</div>;
        }

        return messages.map((msg, index) => {
          const contentIndex = contentMessages.indexOf(msg);
          const isFoundation = foundationMarkers.includes(contentIndex);
          const isMerged = msg.mergedFrom || msg.origin;
          const hasSuggestions = msg.suggestions && (msg.suggestions.branches?.length > 0 || msg.suggestions.quick_answers?.length > 0);

          return (
            <div
              className={`message ${msg.role} ${isFoundation ? 'is-foundation' : ''} ${isMerged ? 'is-merged' : ''}`}
              key={index}
            >
              <div className="role">{msg.role}</div>
              {isMerged && (
                <div className="merged-badge">â†© Merged from: {msg.origin || msg.mergedFrom?.branchTitle}</div>
              )}
              {msg.role !== 'system' && (
                <button
                  className={`foundation-btn ${isFoundation ? 'marked' : ''}`}
                  onClick={() => onToggleFoundation(nodeId, contentIndex)}
                  title={isFoundation ? 'Unmark as foundation' : 'Mark as understood (foundation)'}
                >
                  {isFoundation ? 'â˜…' : 'â˜†'}
                </button>
              )}
              <div className="message-content">
                {msg.role === 'assistant' ? renderMarkdown(msg.text) : <p>{msg.text}</p>}
              </div>

              {hasSuggestions && (
                <div className="suggestions-container">
                  {msg.suggestions.branches?.length > 0 && (
                    <div className="branch-suggestions">
                      <div className="suggestions-label">Explore deeper:</div>
                      <div className="suggestion-chips">
                        {msg.suggestions.branches.map((branch, i) => (
                          <button
                            key={i}
                            className="suggestion-chip branch-chip"
                            onClick={() => onFork(branch)}
                            title={`Fork into: ${branch}`}
                          >
                            <span className="chip-icon">â†³</span>
                            {branch}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}

                  {msg.suggestions.quick_answers?.length > 0 && (
                    <div className="quick-replies">
                      <div className="suggestions-label">Quick reply:</div>
                      <div className="suggestion-chips">
                        {msg.suggestions.quick_answers.map((answer, i) => (
                          <button
                            key={i}
                            className="suggestion-chip answer-chip"
                            onClick={() => onQuickReply(answer)}
                            title={`Reply: ${answer}`}
                          >
                            {answer}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        });
      }

      // ============================================
      // UI COMPONENTS - Expertise Selector
      // ============================================
      function ExpertiseSelector({ onSelect, currentLevel }) {
        const levels = [
          { value: 1, label: 'Novice', desc: 'New to this topic' },
          { value: 2, label: 'Beginner', desc: 'Know the basics' },
          { value: 3, label: 'Intermediate', desc: 'Some experience' },
          { value: 4, label: 'Advanced', desc: 'Solid understanding' },
          { value: 5, label: 'Expert', desc: 'Deep expertise' },
        ];

        return (
          <div className="expertise-selector">
            <div className="expertise-header">
              <span className="expertise-icon">ðŸ“Š</span>
              What's your familiarity with this topic?
            </div>
            <div className="expertise-levels">
              {levels.map((level) => (
                <button
                  key={level.value}
                  className={`expertise-btn ${currentLevel === level.value ? 'selected' : ''}`}
                  onClick={() => onSelect(level.value)}
                  title={level.desc}
                >
                  <span className="level-label">{level.label}</span>
                </button>
              ))}
            </div>
            <div className="expertise-hint">
              This helps tailor explanations to your level
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Composer
      // ============================================
      function Composer({ onSend, disabled, onFork, compact = false, showExpertise, expertiseLevel, onSetExpertise }) {
        const [input, setInput] = useState("");

        const handleSubmit = (e) => {
          e.preventDefault();
          if (!input.trim()) return;
          onSend(input.trim());
          setInput("");
        };

        const handleKeyDown = (e) => {
          // CMD+Enter (Mac) or Ctrl+Enter (Windows) to send
          if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
            e.preventDefault();
            if (input.trim() && !disabled) {
              onSend(input.trim());
              setInput("");
            }
          }
        };

        const handleFork = () => {
          const text = selectionText();
          onFork(text);
        };

        return (
          <div className="composer">
            {showExpertise && !expertiseLevel && (
              <div className="composer-expertise">
                <ExpertiseSelector onSelect={onSetExpertise} currentLevel={expertiseLevel} />
              </div>
            )}
            <form onSubmit={handleSubmit}>
              <textarea
                placeholder={showExpertise && !expertiseLevel ? "Select your experience level above, then ask your question..." : "Ask or explore something..."}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={disabled}
              ></textarea>
              <button type="submit" className="primary-btn" disabled={disabled}>
                Send
              </button>
              <button type="button" className="ghost-btn" onClick={handleFork}>
                Fork
              </button>
            </form>
            {!compact && <div className="footer-hint">âŒ˜+Enter to send â€¢ Highlight text â†’ Fork to explore deeper</div>}
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Canvas Controls
      // ============================================
      function CanvasControls({ onZoomIn, onZoomOut, onReset, onNewThread }) {
        return (
          <div className="canvas-controls">
            <button onClick={onZoomIn} title="Zoom in">+</button>
            <button onClick={onZoomOut} title="Zoom out">âˆ’</button>
            <button onClick={onReset} title="Reset view">âŒ‚</button>
            <button onClick={onNewThread} title="New top-level thread" className="new-thread-btn">+ New</button>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Tree Canvas Node
      // ============================================
      function TreeCanvasNode({ node, position, isActive, onClick }) {
        return (
          <div
            className={`tree-canvas-node ${isActive ? 'active' : ''} health-${node.health || 'exploring'}`}
            style={{ left: position.x, top: position.y }}
            onClick={() => onClick(node.id)}
          >
            <div className={`node-health-dot ${node.health || 'exploring'}`} />
            <div className="node-header">
              <span className="node-depth">[D{position.depth}]</span>
              <span className="node-title">{node.title}</span>
            </div>
            <div className="node-meta">
              {node.messages.length} msgs â€¢ {node.children?.length || 0} forks
              {node.foundationMarkers?.length > 0 && ` â€¢ ${node.foundationMarkers.length}â˜…`}
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Tree Canvas
      // ============================================
      function TreeCanvas({
        trees,
        activeId,
        onSelect,
        positions,
        transform,
        onTransformChange,
        onNewThread,
      }) {
        const canvasRef = useRef(null);
        const [isPanning, setIsPanning] = useState(false);
        const [panStart, setPanStart] = useState({ x: 0, y: 0 });

        const handleMouseDown = (e) => {
          // Don't pan if clicking on a node
          if (e.target.closest('.tree-canvas-node')) {
            return;
          }
          e.preventDefault();
          setIsPanning(true);
          setPanStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
        };

        const handleMouseMove = (e) => {
          if (!isPanning) return;
          onTransformChange({
            ...transform,
            x: e.clientX - panStart.x,
            y: e.clientY - panStart.y,
          });
        };

        const handleMouseUp = () => {
          setIsPanning(false);
        };

        const handleWheel = (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          const newScale = Math.max(0.3, Math.min(2, transform.scale * delta));
          onTransformChange({ ...transform, scale: newScale });
        };

        useEffect(() => {
          const canvas = canvasRef.current;
          if (canvas) {
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            return () => canvas.removeEventListener('wheel', handleWheel);
          }
        }, [transform]);

        // Collect all nodes for rendering
        const collectNodes = (node, acc = []) => {
          if (!node) return acc;
          acc.push(node);
          (node.children || []).forEach(child => collectNodes(child, acc));
          return acc;
        };
        const allNodes = trees.flatMap(t => collectNodes(t, []));

        // Generate edges
        const renderEdges = () => {
          const edges = [];
          const traverse = (node) => {
            if (!node) return;
            const parentPos = positions[node.id];
            if (!parentPos) return;

            (node.children || []).forEach(child => {
              const childPos = positions[child.id];
              if (!childPos) return;

              const startX = parentPos.x + NODE_WIDTH / 2;
              const startY = parentPos.y + NODE_HEIGHT;
              const endX = childPos.x + NODE_WIDTH / 2;
              const endY = childPos.y;
              const midY = (startY + endY) / 2;

              edges.push(
                <path
                  key={`${node.id}-${child.id}`}
                  className={`tree-edge edge-${child.health || 'exploring'}`}
                  d={`M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`}
                />
              );
              traverse(child);
            });
          };
          trees.forEach(t => traverse(t));
          return edges;
        };

        return (
          <div
            className="tree-canvas-container"
            ref={canvasRef}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            <CanvasControls
              onZoomIn={() => onTransformChange({ ...transform, scale: Math.min(2, transform.scale * 1.2) })}
              onZoomOut={() => onTransformChange({ ...transform, scale: Math.max(0.3, transform.scale / 1.2) })}
              onReset={() => onTransformChange({ x: 0, y: 0, scale: 1 })}
              onNewThread={onNewThread}
            />
            <div
              className="canvas-content"
              style={{
                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
              }}
            >
              <svg className="edge-layer" style={{ width: 3000, height: 2000 }}>
                {renderEdges()}
              </svg>
              {allNodes.map(node => {
                const pos = positions[node.id];
                if (!pos) return null;
                return (
                  <TreeCanvasNode
                    key={node.id}
                    node={node}
                    position={pos}
                    isActive={activeId === node.id}
                    onClick={onSelect}
                  />
                );
              })}
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Node Panel (Chat View)
      // ============================================
      function NodePanel({
        node,
        onClose,
        onSend,
        onFork,
        onToggleFoundation,
        onCloseWithMerge,
        lineage,
        onJump,
        isLoading,
        onSetExpertise,
      }) {
        const [width, setWidth] = useState(380);
        const [isResizing, setIsResizing] = useState(false);
        const panelRef = useRef(null);

        const handleMouseDown = (e) => {
          e.preventDefault();
          setIsResizing(true);
        };

        useEffect(() => {
          const handleMouseMove = (e) => {
            if (!isResizing) return;
            const newWidth = window.innerWidth - e.clientX;
            setWidth(Math.max(280, Math.min(newWidth, window.innerWidth * 0.7)));
          };

          const handleMouseUp = () => {
            setIsResizing(false);
          };

          if (isResizing) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
          }

          return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
          };
        }, [isResizing]);

        if (!node) return null;

        return (
          <div className="node-panel" ref={panelRef} style={{ width: `${width}px` }}>
            <div className="panel-resize-handle" onMouseDown={handleMouseDown} />
            <div className="panel-header">
              <div>
                <h2 className="panel-title">{node.title}</h2>
                <div className="panel-meta">
                  Depth {node.depth} â€¢ {node.messages.length} messages
                  {node.foundationMarkers?.length > 0 && ` â€¢ ${node.foundationMarkers.length} foundations`}
                </div>
                <div className="breadcrumbs">
                  {lineage.map((item, idx) => (
                    <span key={item.id} className="crumb" onClick={() => onJump(item.id)}>
                      {item.title}
                      {idx < lineage.length - 1 && <span className="crumb-divider">/</span>}
                    </span>
                  ))}
                </div>
              </div>
              <div className="panel-actions">
                {node.id !== 'root' && node.parentId && (
                  <button className="ghost-btn" onClick={() => onCloseWithMerge(node.id)} title="Close & merge to parent">
                    â†© Merge
                  </button>
                )}
                <button className="ghost-btn" onClick={onClose} title="Close panel">
                  âœ•
                </button>
              </div>
            </div>
            <div className="panel-body chat-body">
              <MessageList
                messages={node.messages}
                foundationMarkers={node.foundationMarkers || []}
                onToggleFoundation={onToggleFoundation}
                nodeId={node.id}
                onFork={(topic) => onFork(node.id, topic)}
                onQuickReply={(text) => onSend(node.id, text)}
              />
              {isLoading && (
                <div className="message assistant loading">
                  <div className="role">ASSISTANT</div>
                  <p className="thinking-indicator">
                    <span className="thinking-dots">thinking</span>
                  </p>
                </div>
              )}
            </div>
            <Composer
              onSend={(text) => onSend(node.id, text)}
              onFork={(text) => onFork(node.id, text)}
              disabled={isLoading}
              compact
              showExpertise={node.parentId === null && node.messages.filter(m => m.role === 'user').length === 0}
              expertiseLevel={node.expertiseLevel}
              onSetExpertise={(level) => onSetExpertise(node.id, level)}
            />
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Merge Preview Modal
      // ============================================
      function MergePreview({ sourceNode, targetNode, onConfirm, onCancel }) {
        const summary = useMemo(() =>
          summarizeMessages(sourceNode.messages, sourceNode.foundationMarkers || []),
          [sourceNode]
        );

        return (
          <div className="merge-preview-overlay" onClick={onCancel}>
            <div className="merge-preview-modal" onClick={e => e.stopPropagation()}>
              <div className="merge-header">
                <span className="ascii-arrow">{'>>'}</span>
                Merging "{sourceNode.title}" â†’ "{targetNode.title}"
              </div>

              <div className="merge-content">
                <div className="section">
                  <h4>Content to merge:</h4>
                  <pre className="summary-preview">{summary}</pre>
                </div>

                {sourceNode.foundationMarkers?.length > 0 && (
                  <div className="section">
                    <h4>Foundations ({sourceNode.foundationMarkers.length}):</h4>
                    {sourceNode.foundationMarkers.map(idx => {
                      const msg = sourceNode.messages.filter(m => m.role !== 'system')[idx];
                      return msg ? (
                        <div key={idx} className="foundation-item">
                          â˜… {msg.text.slice(0, 80)}...
                        </div>
                      ) : null;
                    })}
                  </div>
                )}
              </div>

              <div className="merge-actions">
                <button className="secondary-btn" onClick={onCancel}>
                  Cancel
                </button>
                <button className="primary-btn" onClick={onConfirm}>
                  Confirm Merge
                </button>
              </div>
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Settings Modal
      // ============================================
      function SettingsModal({ apiKey, setApiKey, model, setModel, onClose }) {
        const [tempKey, setTempKey] = useState(apiKey);
        const [tempModel, setTempModel] = useState(model);

        const handleSave = () => {
          setApiKey(tempKey);
          setModel(tempModel);
          localStorage.setItem(STORAGE_KEY_API, tempKey);
          localStorage.setItem(STORAGE_KEY_MODEL, tempModel);
          onClose();
        };

        const handleClear = () => {
          setTempKey("");
          setApiKey("");
          localStorage.removeItem(STORAGE_KEY_API);
        };

        return (
          <div className="merge-preview-overlay" onClick={onClose}>
            <div className="merge-preview-modal settings-modal" onClick={e => e.stopPropagation()}>
              <div className="merge-header">
                <span className="ascii-arrow">âš™</span>
                Settings
              </div>

              <div className="merge-content">
                <div className="section">
                  <h4>Anthropic API Key</h4>
                  <p className="settings-hint">Get your API key from console.anthropic.com</p>
                  <input
                    type="password"
                    className="settings-input"
                    placeholder="sk-ant-..."
                    value={tempKey}
                    onChange={(e) => setTempKey(e.target.value)}
                  />
                  {tempKey && (
                    <button className="ghost-btn" onClick={handleClear} style={{marginTop: 8}}>
                      Clear key
                    </button>
                  )}
                </div>

                <div className="section">
                  <h4>Model</h4>
                  <div className="model-options">
                    {MODELS.map(m => (
                      <label key={m.id} className={`model-option ${tempModel === m.id ? 'selected' : ''}`}>
                        <input
                          type="radio"
                          name="model"
                          value={m.id}
                          checked={tempModel === m.id}
                          onChange={() => setTempModel(m.id)}
                        />
                        <div className="model-info">
                          <span className="model-name">{m.name}</span>
                          <span className="model-desc">{m.description}</span>
                        </div>
                      </label>
                    ))}
                  </div>
                </div>
              </div>

              <div className="merge-actions">
                <button className="secondary-btn" onClick={onClose}>
                  Cancel
                </button>
                <button className="primary-btn" onClick={handleSave}>
                  Save Settings
                </button>
              </div>
            </div>
          </div>
        );
      }

      // ============================================
      // MAIN APP
      // ============================================
      function App() {
        const [nodes, setNodes] = useState({
          root: createNode({
            id: "root",
            title: "Main Thread",
            messages: initialRootMessages,
            parentId: null
          }),
        });
        const [activeId, setActiveId] = useState("root");
        const [showPanel, setShowPanel] = useState(false);
        const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
        const [mergePreview, setMergePreview] = useState(null);

        // API and settings state
        const [apiKey, setApiKey] = useState(() => localStorage.getItem(STORAGE_KEY_API) || "");
        const [model, setModel] = useState(() => localStorage.getItem(STORAGE_KEY_MODEL) || MODELS[0].id);
        const [showSettings, setShowSettings] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        // Build enriched tree (supports multiple top-level threads)
        const trees = useMemo(() => {
          const childrenMap = {};
          const topLevelNodes = [];

          Object.values(nodes).forEach((node) => {
            if (node.parentId === null) {
              topLevelNodes.push(node);
            } else {
              childrenMap[node.parentId] = childrenMap[node.parentId] || [];
              childrenMap[node.parentId].push(node);
            }
          });

          const attach = (node, depth = 0) => {
            const enriched = {
              ...node,
              depth,
              children: (childrenMap[node.id] || [])
                .filter(child => child.status !== 'closed')
                .sort((a, b) => a.createdAt - b.createdAt)
                .map((child) => attach(child, depth + 1)),
            };
            return enriched;
          };

          return topLevelNodes
            .sort((a, b) => a.createdAt - b.createdAt)
            .map(node => attach(node, 0));
        }, [nodes]);

        // For backwards compatibility, also expose single tree
        const tree = trees[0] || null;

        // Calculate positions for canvas (handles multiple trees)
        const positions = useMemo(() => {
          const allPositions = {};
          let xOffset = 50;

          trees.forEach((t) => {
            if (!t) return;
            const treePositions = calculateTreeLayout(t);

            // Find the width of this tree
            let maxX = 0;
            Object.entries(treePositions).forEach(([id, pos]) => {
              maxX = Math.max(maxX, pos.x + NODE_WIDTH);
            });

            // Add positions with offset
            Object.entries(treePositions).forEach(([id, pos]) => {
              allPositions[id] = {
                ...pos,
                x: pos.x + xOffset - 100, // Adjust for the 100 starting offset in calculateTreeLayout
              };
            });

            xOffset += maxX + HORIZONTAL_GAP;
          });

          return allPositions;
        }, [trees]);

        // Flatten tree for lookups
        const flattenTree = (node, depth = 0) => {
          if (!node) return [];
          const current = { ...node, depth };
          const children = node.children || [];
          return [current, ...children.flatMap((child) => flattenTree(child, depth + 1))];
        };

        const nodesById = useMemo(() => {
          const list = trees.flatMap(t => flattenTree(t));
          return list.reduce((acc, n) => ({ ...acc, [n.id]: n }), {});
        }, [trees]);

        // Calculate max depth
        const maxDepth = useMemo(() => {
          let max = 0;
          const traverse = (node, depth = 0) => {
            if (!node) return;
            max = Math.max(max, depth);
            (node.children || []).forEach(child => traverse(child, depth + 1));
          };
          trees.forEach(t => traverse(t));
          return max;
        }, [trees]);

        // Current depth
        const currentDepth = nodesById[activeId]?.depth || 0;

        // Lineage for breadcrumbs
        const lineage = useMemo(() => {
          const path = [];
          let cursor = nodesById[activeId];
          while (cursor) {
            path.unshift(cursor);
            cursor = cursor.parentId ? nodesById[cursor.parentId] : null;
          }
          return path;
        }, [activeId, nodesById]);

        // Message handlers
        const addMessages = (id, newMessages) => {
          setNodes((prev) => ({
            ...prev,
            [id]: {
              ...prev[id],
              messages: [...prev[id].messages, ...newMessages],
            },
          }));
        };

        const simulateAssistant = (question, fromId) => {
          const parent = nodes[fromId];
          const context = parent.messages
            .slice(-3)
            .map((m) => `${m.role}: ${m.text}`)
            .join(" | ");
          return `Building on ${parent.title}'s context. ${context ? `Considering: "${context.slice(0, 100)}..."` : ''} Here's a thoughtful exploration of "${question}".`;
        };

        const handleSend = async (id, text) => {
          // Add user message immediately
          addMessages(id, [{ role: "user", text }]);

          if (!apiKey) {
            addMessages(id, [{
              role: "assistant",
              text: "Please add your Anthropic API key in Settings (âš™) to get AI responses."
            }]);
            setShowSettings(true);
            return;
          }

          setIsLoading(true);
          setError(null);

          try {
            const node = nodes[id];
            const conversationHistory = [...node.messages, { role: "user", text }];

            // Build system prompt with context about the conversation
            const depth = nodesById[id]?.depth || 0;
            const expertiseLevel = node.expertiseLevel;
            const isFirstMessage = node.messages.filter(m => m.role === 'user').length === 0;
            const isTopLevel = node.parentId === null;

            const expertiseContext = expertiseLevel
              ? `The user has indicated they are at expertise level ${expertiseLevel}/5 (1=complete novice, 5=expert).`
              : isTopLevel && isFirstMessage
                ? `This is the start of a new topic. Gauge their familiarity level before diving deep.`
                : '';

            const depthContext = depth > 0
              ? `Current exploration depth: ${depth}. The user has branched ${depth} level(s) deep into subtopics.`
              : '';

            const systemPrompt = `You are a thoughtful tutor in Learnly, helping users build deep understanding through the Socratic method and structured exploration.

## Your Teaching Approach:
1. **Assess first**: Before explaining, understand what the user already knows
2. **Build foundations**: Ensure prerequisites are solid before advancing
3. **Scaffold learning**: Break complex topics into digestible pieces
4. **Check understanding**: Pause to verify comprehension before moving on
5. **Encourage curiosity**: Highlight interesting tangents worth exploring

${expertiseContext}
${depthContext}

## Response Style:
- Be conversational but substantive
- Use analogies and examples the user can relate to
- Format with markdown: **bold** for key terms, bullet lists for concepts
- Keep responses focused - don't overwhelm with too much at once

## IMPORTANT - End every response with this JSON block:

\`\`\`suggestions
{
  "branches": ["Subtopic 1", "Subtopic 2", "Subtopic 3"],
  "quick_answers": ["I understand this", "Explain more simply", "Give me an example"]
}
\`\`\`

- **branches**: 2-4 specific subtopics to explore deeper (become fork buttons)
- **quick_answers**: 2-3 short responses the user can click to quickly reply (like "Yes, I know this", "Not sure, explain more", "Let's skip this"). These should be contextual to what you just asked or explained.

Topic: "${node.title}"
Help the user build genuine understanding.`;

            const response = await sendToClaudeAPI(
              conversationHistory,
              apiKey,
              model,
              systemPrompt
            );

            // Parse the response to extract suggestions
            const { cleanText, suggestions } = parseAIResponse(response);
            addMessages(id, [{
              role: "assistant",
              text: cleanText,
              suggestions: suggestions
            }]);
          } catch (err) {
            console.error("API Error:", err);
            setError(err.message);
            addMessages(id, [{
              role: "assistant",
              text: `Error: ${err.message}\n\nPlease check your API key in Settings.`
            }]);
          } finally {
            setIsLoading(false);
          }
        };

        const makeTitle = (parentTitle, selection) => {
          if (selection) {
            const trimmed = selection.slice(0, 28);
            return `${trimmed}${selection.length > 28 ? "..." : ""}`;
          }
          return `${parentTitle} fork`;
        };

        const handleFork = (fromId, explicitSelection) => {
          const base = nodes[fromId];
          const picked = (explicitSelection && explicitSelection.trim()) || selectionText();
          const contextSnippet = picked || base.messages.slice(-1).map((m) => m.text).join(" ").slice(0, 50);
          const id = `node-${Date.now()}-${Math.round(Math.random() * 9999)}`;

          const newNode = createNode({
            id,
            parentId: fromId,
            title: makeTitle(base.title, contextSnippet),
            messages: [
              {
                role: "system",
                origin: base.title,
                text: `Forked from "${base.title}": ${contextSnippet || "exploring new direction"}`,
              },
              { role: "assistant", text: "What aspect would you like to explore in this branch?" },
            ],
          });

          setNodes((prev) => ({ ...prev, [id]: newNode }));
          setActiveId(id);
          setShowPanel(true);
        };

        const handleNewChat = () => {
          const id = `node-${Date.now()}-${Math.round(Math.random() * 9999)}`;
          const topLevelCount = Object.values(nodes).filter((n) => n.parentId === null).length;

          const newNode = createNode({
            id,
            parentId: null, // Top-level thread (sibling of root)
            title: `Thread ${topLevelCount + 1}`,
            messages: [{ role: "assistant", text: "New exploration thread started. What would you like to learn about?" }],
          });

          setNodes((prev) => ({ ...prev, [id]: newNode }));
          setActiveId(id);
          setShowPanel(true);
        };

        const handleToggleFoundation = (nodeId, messageIndex) => {
          setNodes(prev => {
            const node = prev[nodeId];
            const isMarked = node.foundationMarkers.includes(messageIndex);
            const newMarkers = isMarked
              ? node.foundationMarkers.filter(i => i !== messageIndex)
              : [...node.foundationMarkers, messageIndex];

            const updatedNode = {
              ...node,
              foundationMarkers: newMarkers,
            };
            updatedNode.health = calculateHealth(updatedNode);

            return { ...prev, [nodeId]: updatedNode };
          });
        };

        const handleSetExpertise = (nodeId, level) => {
          setNodes(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              expertiseLevel: level,
            }
          }));
        };

        const handleCloseWithMerge = (id) => {
          const node = nodes[id];
          const targetId = node.parentId || 'root';
          setMergePreview({ sourceId: id, targetId });
        };

        const confirmMerge = () => {
          if (!mergePreview) return;

          const { sourceId, targetId } = mergePreview;
          const sourceNode = nodes[sourceId];
          const targetNode = nodes[targetId];

          const summary = summarizeMessages(sourceNode.messages, sourceNode.foundationMarkers);

          setNodes((prev) => ({
            ...prev,
            [targetId]: {
              ...targetNode,
              messages: [
                ...targetNode.messages,
                {
                  role: "assistant",
                  origin: sourceNode.title,
                  mergedFrom: {
                    branchId: sourceId,
                    branchTitle: sourceNode.title,
                    timestamp: Date.now(),
                    foundationCount: sourceNode.foundationMarkers.length,
                  },
                  text: `Merged insights from "${sourceNode.title}":\n\n${summary}`,
                },
              ],
              mergeHistory: [...(targetNode.mergeHistory || []), {
                branchId: sourceId,
                branchTitle: sourceNode.title,
                timestamp: Date.now(),
              }],
            },
            [sourceId]: { ...sourceNode, status: "closed" },
          }));

          setMergePreview(null);
          setActiveId(targetId);
        };

        const selectNode = (id) => {
          setActiveId(id);
          setShowPanel(true);
        };

        const closePanel = () => {
          setShowPanel(false);
        };

        return (
          <div className="app-shell">
            <Sidebar
              trees={trees}
              activeId={activeId}
              onSelect={selectNode}
              onNewChat={handleNewChat}
              currentDepth={currentDepth}
              maxDepth={maxDepth}
              onJumpTo={selectNode}
              onOpenSettings={() => setShowSettings(true)}
              hasApiKey={!!apiKey}
            />

            <div className="main-area">
              <TreeCanvas
                trees={trees}
                activeId={activeId}
                onSelect={selectNode}
                positions={positions}
                transform={transform}
                onTransformChange={setTransform}
                onNewThread={handleNewChat}
              />

              {showPanel && (
                <NodePanel
                  node={nodesById[activeId]}
                  onClose={closePanel}
                  onSend={handleSend}
                  onFork={handleFork}
                  onToggleFoundation={handleToggleFoundation}
                  onCloseWithMerge={handleCloseWithMerge}
                  lineage={lineage}
                  onJump={selectNode}
                  isLoading={isLoading}
                  onSetExpertise={handleSetExpertise}
                />
              )}
            </div>

            {mergePreview && (
              <MergePreview
                sourceNode={nodes[mergePreview.sourceId]}
                targetNode={nodes[mergePreview.targetId]}
                onConfirm={confirmMerge}
                onCancel={() => setMergePreview(null)}
              />
            )}

            {showSettings && (
              <SettingsModal
                apiKey={apiKey}
                setApiKey={setApiKey}
                model={model}
                setModel={setModel}
                onClose={() => setShowSettings(false)}
              />
            )}
          </div>
        );
      }

      // ============================================
      // RENDER
      // ============================================
      const container = document.getElementById("root");
      const root = ReactDOM.createRoot(container);
      root.render(<App />);
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learnly - Visual Learning Tree</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useState, useMemo, useRef, useCallback } = React;

      // ============================================
      // CONSTANTS & UTILITIES
      // ============================================
      const NODE_WIDTH = 200;
      const NODE_HEIGHT = 70;
      const HORIZONTAL_GAP = 50;
      const VERTICAL_GAP = 80;
      const API_ENDPOINT = "/api/chat/stream";
      const STORAGE_KEY_API = "learnly_api_key";
      const STORAGE_KEY_MODEL = "learnly_model";

      const MODELS = [
        { id: "claude-sonnet-4-20250514", name: "Claude Sonnet 4", description: "Best balance of speed and intelligence" },
        { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", description: "Fast and capable" },
        { id: "claude-3-5-haiku-20241022", name: "Claude 3.5 Haiku", description: "Fastest, great for quick responses" },
      ];

      const initialRootMessages = [
        {
          role: "assistant",
          text: "Welcome to Learnly. Ask any question to begin exploring. Fork conversations to dig deeper into specific concepts. Mark messages as 'foundations' when you understand them.\n\nClick the âš™ button in the sidebar to add your Anthropic API key.",
        },
      ];

      // ============================================
      // API HELPER - Streaming
      // ============================================
      const streamToClaudeAPI = async (messages, apiKey, model, systemPrompt, onChunk) => {
        const response = await fetch(API_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-API-Key": apiKey,
          },
          body: JSON.stringify({
            messages: messages.map(m => ({
              role: m.role === "user" ? "user" : "assistant",
              content: m.text
            })).filter(m => m.role === "user" || m.role === "assistant"),
            system: systemPrompt,
            model: model,
            max_tokens: 2048,
          }),
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`API request failed: ${errorText}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullText = "";
        let buffer = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || ""; // Keep incomplete line in buffer

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") {
                return fullText;
              }

              try {
                const parsed = JSON.parse(data);
                if (parsed.type === "text") {
                  fullText += parsed.text;
                  onChunk(fullText);
                } else if (parsed.type === "error") {
                  throw new Error(parsed.error);
                }
              } catch (e) {
                if (e.message !== "Unexpected end of JSON input") {
                  console.warn("Parse error:", e);
                }
              }
            }
          }
        }

        return fullText;
      };

      // ============================================
      // DATA MODELS
      // ============================================
      const createNode = ({
        id,
        parentId = null,
        title,
        messages,
        status = "open",
        createdAt = Date.now(),
        health = "exploring",
        foundationMarkers = [],
        mergeHistory = [],
        expertiseLevel = null, // null = not set, 1-5 scale (novice to expert)
      }) => ({
        id,
        parentId,
        title,
        messages,
        status,
        createdAt,
        health,
        foundationMarkers,
        mergeHistory,
        expertiseLevel,
      });

      const selectionText = () => {
        const text = window.getSelection().toString();
        return text.trim();
      };

      const summarizeMessages = (messages, foundationMarkers = []) => {
        if (!messages || messages.length === 0) return "No content to merge.";

        const contentMessages = messages.filter((m) => m.role !== "system");

        // Prioritize foundation-marked messages
        const foundations = foundationMarkers
          .map(idx => contentMessages[idx])
          .filter(Boolean)
          .map(m => `â˜… ${m.text.slice(0, 150)}`);

        // Get key Q&A pairs
        const exchanges = [];
        for (let i = 0; i < contentMessages.length - 1; i++) {
          if (contentMessages[i].role === 'user' && contentMessages[i + 1].role === 'assistant') {
            exchanges.push({
              q: contentMessages[i].text.slice(0, 80),
              a: contentMessages[i + 1].text.slice(0, 150)
            });
          }
        }

        let summary = '';
        if (foundations.length > 0) {
          summary += '## Key Foundations:\n' + foundations.join('\n') + '\n\n';
        }
        if (exchanges.length > 0) {
          summary += '## Discussion:\n';
          exchanges.slice(-3).forEach(ex => {
            summary += `Q: ${ex.q}\nA: ${ex.a}\n\n`;
          });
        }

        return summary || contentMessages.slice(-4).map(m => `${m.role}: ${m.text.slice(0, 100)}`).join('\n');
      };

      const calculateHealth = (node) => {
        const contentMessages = node.messages.filter(m => m.role !== 'system');
        if (contentMessages.length === 0) return 'exploring';

        const ratio = node.foundationMarkers.length / contentMessages.length;
        if (ratio >= 0.4) return 'grounded';
        if (ratio >= 0.15) return 'exploring';
        return 'needs-review';
      };

      // Parse AI response to extract suggestions and clean text
      const parseAIResponse = (text) => {
        const suggestionsMatch = text.match(/```suggestions\s*([\s\S]*?)```/);
        let suggestions = { branches: [], quick_answers: [], title: null };
        let cleanText = text;

        if (suggestionsMatch) {
          try {
            const parsed = JSON.parse(suggestionsMatch[1].trim());
            suggestions = {
              title: parsed.title || null,
              branches: parsed.branches || [],
              quick_answers: parsed.quick_answers || parsed.questions || [] // support both
            };
            cleanText = text.replace(/```suggestions\s*[\s\S]*?```/, '').trim();
          } catch (e) {
            console.warn('Failed to parse suggestions:', e);
          }
        }

        return { cleanText, suggestions };
      };

      // Simple markdown renderer
      const renderMarkdown = (text) => {
        if (!text) return null;

        // Split into lines and process
        const lines = text.split('\n');
        const elements = [];
        let listItems = [];
        let inList = false;

        const processInline = (line) => {
          // Bold: **text** or __text__
          line = line.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
          line = line.replace(/__(.+?)__/g, '<strong>$1</strong>');
          // Italic: *text* or _text_
          line = line.replace(/\*([^*]+)\*/g, '<em>$1</em>');
          line = line.replace(/_([^_]+)_/g, '<em>$1</em>');
          // Code: `text`
          line = line.replace(/`([^`]+)`/g, '<code>$1</code>');
          return line;
        };

        lines.forEach((line, idx) => {
          const trimmed = line.trim();

          // Bullet list item
          if (trimmed.match(/^[-*â€¢]\s+/)) {
            const content = trimmed.replace(/^[-*â€¢]\s+/, '');
            listItems.push(content);
            inList = true;
          } else {
            // Flush list if we were in one
            if (inList && listItems.length > 0) {
              elements.push(
                <ul key={`list-${idx}`} className="md-list">
                  {listItems.map((item, i) => (
                    <li key={i} dangerouslySetInnerHTML={{ __html: processInline(item) }} />
                  ))}
                </ul>
              );
              listItems = [];
              inList = false;
            }

            // Headers
            if (trimmed.startsWith('### ')) {
              elements.push(<h4 key={idx} className="md-h4">{trimmed.slice(4)}</h4>);
            } else if (trimmed.startsWith('## ')) {
              elements.push(<h3 key={idx} className="md-h3">{trimmed.slice(3)}</h3>);
            } else if (trimmed.startsWith('# ')) {
              elements.push(<h2 key={idx} className="md-h2">{trimmed.slice(2)}</h2>);
            } else if (trimmed) {
              elements.push(
                <p key={idx} dangerouslySetInnerHTML={{ __html: processInline(trimmed) }} />
              );
            }
          }
        });

        // Flush any remaining list
        if (listItems.length > 0) {
          elements.push(
            <ul key="list-final" className="md-list">
              {listItems.map((item, i) => (
                <li key={i} dangerouslySetInnerHTML={{ __html: processInline(item) }} />
              ))}
            </ul>
          );
        }

        return elements;
      };

      // ============================================
      // TREE LAYOUT CALCULATION
      // ============================================
      const calculateTreeLayout = (tree) => {
        const positions = {};

        const getSubtreeWidth = (node) => {
          if (!node.children || node.children.length === 0) {
            return NODE_WIDTH;
          }
          const childrenWidth = node.children.reduce((sum, child, idx) => {
            return sum + getSubtreeWidth(child) + (idx > 0 ? HORIZONTAL_GAP : 0);
          }, 0);
          return Math.max(NODE_WIDTH, childrenWidth);
        };

        const layoutNode = (node, x, y, depth) => {
          const subtreeWidth = getSubtreeWidth(node);
          const nodeX = x + (subtreeWidth - NODE_WIDTH) / 2;

          positions[node.id] = { x: nodeX, y, depth };

          if (node.children && node.children.length > 0) {
            let childX = x;
            node.children.forEach((child) => {
              const childWidth = getSubtreeWidth(child);
              layoutNode(child, childX, y + NODE_HEIGHT + VERTICAL_GAP, depth + 1);
              childX += childWidth + HORIZONTAL_GAP;
            });
          }
        };

        layoutNode(tree, 100, 80, 0);
        return positions;
      };

      // ============================================
      // UI COMPONENTS - Depth Meter
      // ============================================
      function DepthMeter({ currentDepth, maxDepth }) {
        const segments = 8;
        const threshold = 4;

        const getSegmentClass = (index) => {
          if (index >= currentDepth) return '';
          if (index < 2) return 'filled-green';
          if (index < 4) return 'filled-yellow';
          return 'filled-red';
        };

        return (
          <div className="depth-meter">
            <div className="meter-label">
              DEPTH [{currentDepth}/{maxDepth}]
            </div>
            <div className="meter-bar">
              {Array.from({ length: segments }, (_, i) => (
                <div
                  key={i}
                  className={`meter-segment ${getSegmentClass(i)}`}
                />
              ))}
            </div>
            {currentDepth >= threshold && (
              <div className="depth-warning terminal-glow">
                ! DEEP EXPLORATION !
              </div>
            )}
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Foundation Map
      // ============================================
      function FoundationMap({ trees, onJumpTo }) {
        const allFoundations = useMemo(() => {
          const foundations = [];

          const traverse = (node, depth = 0) => {
            if (!node) return;
            (node.foundationMarkers || []).forEach((idx) => {
              const msg = node.messages.filter(m => m.role !== 'system')[idx];
              if (msg) {
                foundations.push({
                  nodeId: node.id,
                  nodeTitle: node.title,
                  messageIndex: idx,
                  text: msg.text.slice(0, 40) + '...',
                  depth,
                });
              }
            });
            (node.children || []).forEach((child) => traverse(child, depth + 1));
          };

          (trees || []).forEach(t => traverse(t));
          return foundations;
        }, [trees]);

        if (allFoundations.length === 0) return null;

        return (
          <div className="foundation-map">
            <div className="map-header">
              FOUNDATIONS [{allFoundations.length}]
            </div>
            <div className="map-list">
              {allFoundations.map((f, i) => (
                <div
                  key={`${f.nodeId}-${f.messageIndex}`}
                  className="foundation-entry"
                  onClick={() => onJumpTo(f.nodeId)}
                >
                  <span className="foundation-marker">â˜…</span>
                  <span className="foundation-text">{f.text}</span>
                  <span className="foundation-depth">[D{f.depth}]</span>
                </div>
              ))}
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Sidebar
      // ============================================
      function Sidebar({ trees, activeId, onSelect, onNewChat, currentDepth, maxDepth, onJumpTo, onOpenSettings, hasApiKey }) {
        const renderNode = (node, depth = 0) => (
          <li key={node.id}>
            <div className="tree-branch">
              <div
                className={`tree-node ${activeId === node.id ? "active" : ""} health-${node.health || 'exploring'}`}
                onClick={() => onSelect(node.id)}
              >
                <div className="title">
                  <span className="depth-tag">[D{depth}]</span>
                  <span className="text">{node.title}</span>
                </div>
                <div className="meta">
                  {node.children?.length || 0} forks â€¢ {node.messages.length} msgs
                  {node.foundationMarkers?.length > 0 && ` â€¢ ${node.foundationMarkers.length}â˜…`}
                </div>
              </div>
            </div>
            {node.children && node.children.length > 0 && (
              <ul className="tree-children">
                {node.children.map((child) => renderNode(child, depth + 1))}
              </ul>
            )}
          </li>
        );

        return (
          <aside className="sidebar">
            <div className="sidebar-header">
              <div className="sidebar-title-row">
                <h1>Learnly</h1>
                <button
                  className={`settings-btn ${hasApiKey ? 'has-key' : ''}`}
                  onClick={onOpenSettings}
                  title="Settings"
                >
                  âš™
                </button>
              </div>
              <p className="hint">Visual learning through branching exploration</p>
              {!hasApiKey && (
                <div className="api-warning" onClick={onOpenSettings}>
                  âš  Add API key to enable AI
                </div>
              )}
              <button className="primary-btn full-width" onClick={onNewChat}>
                + New Thread
              </button>
            </div>
            <DepthMeter currentDepth={currentDepth} maxDepth={maxDepth} />
            <FoundationMap trees={trees} onJumpTo={onJumpTo} />
            <div className="tree-list-container">
              <ul className="tree-list">
                {trees.map(t => renderNode(t, 0))}
              </ul>
            </div>
          </aside>
        );
      }

      // ============================================
      // UI COMPONENTS - Selection Popup
      // ============================================
      function SelectionPopup({ position, onExplore, onClose }) {
        if (!position) return null;

        return (
          <div
            className="selection-popup"
            style={{ top: position.y, left: position.x }}
          >
            <button onClick={onExplore} className="explore-selection-btn">
              <span className="explore-icon">â†³</span>
              Explore this
            </button>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Message List
      // ============================================
      function MessageList({ messages, foundationMarkers = [], onToggleFoundation, nodeId, onFork, onQuickReply }) {
        const contentMessages = messages.filter(m => m.role !== 'system');
        const [selectionInfo, setSelectionInfo] = useState(null);
        const containerRef = useRef(null);

        // Handle text selection in assistant messages
        const handleMouseUp = (e, msgText) => {
          const selection = window.getSelection();
          const selectedText = selection.toString().trim();

          if (selectedText && selectedText.length > 2 && selectedText.length < 200) {
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const containerRect = containerRef.current?.getBoundingClientRect() || { top: 0, left: 0 };

            // Get surrounding context (the paragraph/sentence containing the selection)
            const fullText = msgText;
            const selectionStart = fullText.indexOf(selectedText);
            let contextStart = Math.max(0, selectionStart - 150);
            let contextEnd = Math.min(fullText.length, selectionStart + selectedText.length + 150);

            // Try to find sentence boundaries
            const beforeText = fullText.slice(contextStart, selectionStart);
            const afterText = fullText.slice(selectionStart + selectedText.length, contextEnd);
            const sentenceStartMatch = beforeText.match(/[.!?]\s+[A-Z][^.!?]*$/);
            const sentenceEndMatch = afterText.match(/^[^.!?]*[.!?]/);

            const contextBefore = sentenceStartMatch ? sentenceStartMatch[0].slice(2) : beforeText.slice(-100);
            const contextAfter = sentenceEndMatch ? sentenceEndMatch[0] : afterText.slice(0, 100);
            const surroundingContext = `...${contextBefore}${selectedText}${contextAfter}...`;

            setSelectionInfo({
              text: selectedText,
              context: surroundingContext,
              fullMessageText: msgText,
              position: {
                x: rect.left - containerRect.left + rect.width / 2,
                y: rect.top - containerRect.top - 40
              }
            });
          } else {
            setSelectionInfo(null);
          }
        };

        const handleExploreSelection = () => {
          if (selectionInfo) {
            // Pass both the selected text and its surrounding context
            onFork(selectionInfo.text, true, selectionInfo.context);
            setSelectionInfo(null);
            window.getSelection().removeAllRanges();
          }
        };

        // Close popup when clicking elsewhere
        useEffect(() => {
          const handleClickOutside = () => {
            setTimeout(() => {
              const selection = window.getSelection();
              if (!selection.toString().trim()) {
                setSelectionInfo(null);
              }
            }, 10);
          };
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
        }, []);

        if (!messages.length) {
          return <div className="empty">No messages yet. Ask something to begin exploring.</div>;
        }

        return (
          <div ref={containerRef} className="message-list-container">
            {selectionInfo && (
              <SelectionPopup
                position={selectionInfo.position}
                onExplore={handleExploreSelection}
                onClose={() => setSelectionInfo(null)}
              />
            )}
            {messages.map((msg, index) => {
              const contentIndex = contentMessages.indexOf(msg);
              const isFoundation = foundationMarkers.includes(contentIndex);
              const isMerged = msg.mergedFrom || msg.origin;
              const hasSuggestions = msg.suggestions && (msg.suggestions.branches?.length > 0 || msg.suggestions.quick_answers?.length > 0);

              const isStreaming = msg.isStreaming;
              const isEmptyStream = isStreaming && (!msg.text || msg.text.length === 0);

              return (
                <div
                  className={`message ${msg.role} ${isFoundation ? 'is-foundation' : ''} ${isMerged ? 'is-merged' : ''} ${isStreaming ? 'streaming' : ''} ${isEmptyStream ? 'empty-stream' : ''}`}
                  key={index}
                  onMouseUp={msg.role === 'assistant' ? (e) => handleMouseUp(e, msg.text) : undefined}
                >
                  <div className="role">{msg.role}</div>
                  {isMerged && (
                    <div className="merged-badge">â†© Merged from: {msg.origin || msg.mergedFrom?.branchTitle}</div>
                  )}
                  {msg.role !== 'system' && (
                    <button
                      className={`foundation-btn ${isFoundation ? 'marked' : ''}`}
                      onClick={() => onToggleFoundation(nodeId, contentIndex)}
                      title={isFoundation ? 'Unmark as foundation' : 'Mark as understood (foundation)'}
                    >
                      {isFoundation ? 'â˜…' : 'â˜†'}
                    </button>
                  )}
                  <div className="message-content">
                    {msg.role === 'assistant' ? renderMarkdown(msg.text) : <p>{msg.text}</p>}
                  </div>

              {hasSuggestions && (
                <div className="suggestions-container">
                  {msg.suggestions.branches?.length > 0 && (
                    <div className="branch-suggestions">
                      <div className="suggestions-label">Explore deeper:</div>
                      <div className="suggestion-chips">
                        {msg.suggestions.branches.map((branch, i) => (
                          <button
                            key={i}
                            className="suggestion-chip branch-chip"
                            onClick={() => onFork(branch, true)}
                            title={`Fork into: ${branch}`}
                          >
                            <span className="chip-icon">â†³</span>
                            {branch}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}

                  {msg.suggestions.quick_answers?.length > 0 && (
                    <div className="quick-replies">
                      <div className="suggestions-label">Quick reply:</div>
                      <div className="suggestion-chips">
                        {msg.suggestions.quick_answers.map((answer, i) => (
                          <button
                            key={i}
                            className="suggestion-chip answer-chip"
                            onClick={() => onQuickReply(answer)}
                            title={`Reply: ${answer}`}
                          >
                            {answer}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}
                </div>
              );
            })}
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Expertise Selector
      // ============================================
      function ExpertiseSelector({ onSelect, currentLevel }) {
        const levels = [
          { value: 1, label: 'Novice', desc: 'New to this topic' },
          { value: 2, label: 'Beginner', desc: 'Know the basics' },
          { value: 3, label: 'Intermediate', desc: 'Some experience' },
          { value: 4, label: 'Advanced', desc: 'Solid understanding' },
          { value: 5, label: 'Expert', desc: 'Deep expertise' },
        ];

        return (
          <div className="expertise-selector">
            <div className="expertise-header">
              <span className="expertise-icon">ðŸ“Š</span>
              What's your familiarity with this topic?
            </div>
            <div className="expertise-levels">
              {levels.map((level) => (
                <button
                  key={level.value}
                  className={`expertise-btn ${currentLevel === level.value ? 'selected' : ''}`}
                  onClick={() => onSelect(level.value)}
                  title={level.desc}
                >
                  <span className="level-label">{level.label}</span>
                </button>
              ))}
            </div>
            <div className="expertise-hint">
              This helps tailor explanations to your level
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Composer
      // ============================================
      function Composer({ onSend, disabled, onFork, compact = false, showExpertise, expertiseLevel, onSetExpertise }) {
        const [input, setInput] = useState("");

        const handleSubmit = (e) => {
          e.preventDefault();
          if (!input.trim()) return;
          onSend(input.trim());
          setInput("");
        };

        const handleKeyDown = (e) => {
          // CMD+Enter (Mac) or Ctrl+Enter (Windows) to send
          if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
            e.preventDefault();
            if (input.trim() && !disabled) {
              onSend(input.trim());
              setInput("");
            }
          }
        };

        const handleFork = () => {
          const text = selectionText();
          onFork(text);
        };

        return (
          <div className="composer">
            {showExpertise && !expertiseLevel && (
              <div className="composer-expertise">
                <ExpertiseSelector onSelect={onSetExpertise} currentLevel={expertiseLevel} />
              </div>
            )}
            <form onSubmit={handleSubmit}>
              <textarea
                placeholder={showExpertise && !expertiseLevel ? "Select your experience level above, then ask your question..." : "Ask or explore something..."}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                disabled={disabled}
              ></textarea>
              <button type="submit" className="primary-btn" disabled={disabled}>
                Send
              </button>
              <button type="button" className="ghost-btn" onClick={handleFork}>
                Fork
              </button>
            </form>
            {!compact && <div className="footer-hint">âŒ˜+Enter to send â€¢ Highlight text â†’ Fork to explore deeper</div>}
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Canvas Controls
      // ============================================
      function CanvasControls({ onZoomIn, onZoomOut, onReset, onNewThread }) {
        return (
          <div className="canvas-controls">
            <button onClick={onZoomIn} title="Zoom in">+</button>
            <button onClick={onZoomOut} title="Zoom out">âˆ’</button>
            <button onClick={onReset} title="Reset view">âŒ‚</button>
            <button onClick={onNewThread} title="New top-level thread" className="new-thread-btn">+ New</button>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Tree Canvas Node
      // ============================================
      function TreeCanvasNode({ node, position, isActive, onClick }) {
        return (
          <div
            className={`tree-canvas-node ${isActive ? 'active' : ''} health-${node.health || 'exploring'}`}
            style={{ left: position.x, top: position.y }}
            onClick={() => onClick(node.id)}
          >
            <div className={`node-health-dot ${node.health || 'exploring'}`} />
            <div className="node-header">
              <span className="node-depth">[D{position.depth}]</span>
              <span className="node-title">{node.title}</span>
            </div>
            <div className="node-meta">
              {node.messages.length} msgs â€¢ {node.children?.length || 0} forks
              {node.foundationMarkers?.length > 0 && ` â€¢ ${node.foundationMarkers.length}â˜…`}
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Tree Canvas
      // ============================================
      function TreeCanvas({
        trees,
        activeId,
        onSelect,
        positions,
        transform,
        onTransformChange,
        onNewThread,
      }) {
        const canvasRef = useRef(null);
        const [isPanning, setIsPanning] = useState(false);
        const [panStart, setPanStart] = useState({ x: 0, y: 0 });

        const handleMouseDown = (e) => {
          // Don't pan if clicking on a node
          if (e.target.closest('.tree-canvas-node')) {
            return;
          }
          e.preventDefault();
          setIsPanning(true);
          setPanStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
        };

        const handleMouseMove = (e) => {
          if (!isPanning) return;
          onTransformChange({
            ...transform,
            x: e.clientX - panStart.x,
            y: e.clientY - panStart.y,
          });
        };

        const handleMouseUp = () => {
          setIsPanning(false);
        };

        const handleWheel = (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          const newScale = Math.max(0.3, Math.min(2, transform.scale * delta));
          onTransformChange({ ...transform, scale: newScale });
        };

        useEffect(() => {
          const canvas = canvasRef.current;
          if (canvas) {
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            return () => canvas.removeEventListener('wheel', handleWheel);
          }
        }, [transform]);

        // Collect all nodes for rendering
        const collectNodes = (node, acc = []) => {
          if (!node) return acc;
          acc.push(node);
          (node.children || []).forEach(child => collectNodes(child, acc));
          return acc;
        };
        const allNodes = trees.flatMap(t => collectNodes(t, []));

        // Generate edges
        const renderEdges = () => {
          const edges = [];
          const traverse = (node) => {
            if (!node) return;
            const parentPos = positions[node.id];
            if (!parentPos) return;

            (node.children || []).forEach(child => {
              const childPos = positions[child.id];
              if (!childPos) return;

              const startX = parentPos.x + NODE_WIDTH / 2;
              const startY = parentPos.y + NODE_HEIGHT;
              const endX = childPos.x + NODE_WIDTH / 2;
              const endY = childPos.y;
              const midY = (startY + endY) / 2;

              edges.push(
                <path
                  key={`${node.id}-${child.id}`}
                  className={`tree-edge edge-${child.health || 'exploring'}`}
                  d={`M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`}
                />
              );
              traverse(child);
            });
          };
          trees.forEach(t => traverse(t));
          return edges;
        };

        return (
          <div
            className="tree-canvas-container"
            ref={canvasRef}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            <CanvasControls
              onZoomIn={() => onTransformChange({ ...transform, scale: Math.min(2, transform.scale * 1.2) })}
              onZoomOut={() => onTransformChange({ ...transform, scale: Math.max(0.3, transform.scale / 1.2) })}
              onReset={() => onTransformChange({ x: 0, y: 0, scale: 1 })}
              onNewThread={onNewThread}
            />
            <div
              className="canvas-content"
              style={{
                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
              }}
            >
              <svg className="edge-layer" style={{ width: 3000, height: 2000 }}>
                {renderEdges()}
              </svg>
              {allNodes.map(node => {
                const pos = positions[node.id];
                if (!pos) return null;
                return (
                  <TreeCanvasNode
                    key={node.id}
                    node={node}
                    position={pos}
                    isActive={activeId === node.id}
                    onClick={onSelect}
                  />
                );
              })}
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Node Panel (Chat View)
      // ============================================
      // Store scroll positions outside component to persist across re-renders
      const scrollPositions = {};

      function NodePanel({
        node,
        onClose,
        onSend,
        onFork,
        onToggleFoundation,
        onCloseWithMerge,
        lineage,
        onJump,
        isLoading,
        onSetExpertise,
      }) {
        const [width, setWidth] = useState(380);
        const [isResizing, setIsResizing] = useState(false);
        const panelRef = useRef(null);
        const chatBodyRef = useRef(null);
        const prevNodeIdRef = useRef(null);
        const prevMessageCountRef = useRef(0);
        const isUserScrolledUpRef = useRef(false);

        const handleMouseDown = (e) => {
          e.preventDefault();
          setIsResizing(true);
        };

        // Track if user has scrolled up from bottom
        const handleScroll = () => {
          if (!chatBodyRef.current) return;
          const { scrollTop, scrollHeight, clientHeight } = chatBodyRef.current;
          const isAtBottom = scrollHeight - scrollTop - clientHeight < 50;
          isUserScrolledUpRef.current = !isAtBottom;

          // Save scroll position for this node
          if (node) {
            scrollPositions[node.id] = scrollTop;
          }
        };

        // Save scroll position when switching away from a node
        useEffect(() => {
          if (prevNodeIdRef.current && prevNodeIdRef.current !== node?.id && chatBodyRef.current) {
            scrollPositions[prevNodeIdRef.current] = chatBodyRef.current.scrollTop;
          }
          prevNodeIdRef.current = node?.id;
        }, [node?.id]);

        // Restore scroll position when switching to a node
        useEffect(() => {
          if (!node || !chatBodyRef.current) return;

          const savedPosition = scrollPositions[node.id];
          if (savedPosition !== undefined) {
            // Restore saved position
            chatBodyRef.current.scrollTop = savedPosition;
            isUserScrolledUpRef.current = false;
          } else {
            // New node - scroll to bottom
            chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight;
          }
        }, [node?.id]);

        // Auto-scroll when new messages arrive (unless user scrolled up)
        useEffect(() => {
          if (!node || !chatBodyRef.current) return;

          const messageCount = node.messages.length;
          const hasNewMessage = messageCount > prevMessageCountRef.current;
          prevMessageCountRef.current = messageCount;

          // Check if the last message is streaming
          const lastMessage = node.messages[node.messages.length - 1];
          const isStreaming = lastMessage?.isStreaming;

          // Auto-scroll if: new message arrived OR streaming, AND user hasn't scrolled up
          if ((hasNewMessage || isStreaming) && !isUserScrolledUpRef.current) {
            chatBodyRef.current.scrollTo({
              top: chatBodyRef.current.scrollHeight,
              behavior: isStreaming ? 'auto' : 'smooth'
            });
          }
        }, [node?.messages]);

        useEffect(() => {
          const handleMouseMove = (e) => {
            if (!isResizing) return;
            const newWidth = window.innerWidth - e.clientX;
            setWidth(Math.max(280, Math.min(newWidth, window.innerWidth * 0.7)));
          };

          const handleMouseUp = () => {
            setIsResizing(false);
          };

          if (isResizing) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
          }

          return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
          };
        }, [isResizing]);

        if (!node) return null;

        return (
          <div className="node-panel" ref={panelRef} style={{ width: `${width}px` }}>
            <div className="panel-resize-handle" onMouseDown={handleMouseDown} />
            <div className="panel-header">
              <div>
                <h2 className="panel-title">{node.title}</h2>
                <div className="panel-meta">
                  Depth {node.depth} â€¢ {node.messages.length} messages
                  {node.foundationMarkers?.length > 0 && ` â€¢ ${node.foundationMarkers.length} foundations`}
                </div>
                <div className="breadcrumbs">
                  {lineage.map((item, idx) => (
                    <span key={item.id} className="crumb" onClick={() => onJump(item.id)}>
                      {item.title}
                      {idx < lineage.length - 1 && <span className="crumb-divider">/</span>}
                    </span>
                  ))}
                </div>
              </div>
              <div className="panel-actions">
                {node.id !== 'root' && node.parentId && (
                  <button className="ghost-btn" onClick={() => onCloseWithMerge(node.id)} title="Close & merge to parent">
                    â†© Merge
                  </button>
                )}
                <button className="ghost-btn" onClick={onClose} title="Close panel">
                  âœ•
                </button>
              </div>
            </div>
            <div
              className="panel-body chat-body"
              ref={chatBodyRef}
              onScroll={handleScroll}
            >
              <MessageList
                messages={node.messages}
                foundationMarkers={node.foundationMarkers || []}
                onToggleFoundation={onToggleFoundation}
                nodeId={node.id}
                onFork={(topic, autoSend, immediateContext) => onFork(node.id, topic, autoSend, immediateContext)}
                onQuickReply={(text) => onSend(node.id, text)}
              />
            </div>
            <Composer
              onSend={(text) => onSend(node.id, text)}
              onFork={(text) => onFork(node.id, text)}
              disabled={isLoading}
              compact
              showExpertise={node.parentId === null && node.messages.filter(m => m.role === 'user').length === 0}
              expertiseLevel={node.expertiseLevel}
              onSetExpertise={(level) => onSetExpertise(node.id, level)}
            />
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Merge Preview Modal
      // ============================================
      function MergePreview({ sourceNode, targetNode, onConfirm, onCancel }) {
        const summary = useMemo(() =>
          summarizeMessages(sourceNode.messages, sourceNode.foundationMarkers || []),
          [sourceNode]
        );

        return (
          <div className="merge-preview-overlay" onClick={onCancel}>
            <div className="merge-preview-modal" onClick={e => e.stopPropagation()}>
              <div className="merge-header">
                <span className="ascii-arrow">{'>>'}</span>
                Merging "{sourceNode.title}" â†’ "{targetNode.title}"
              </div>

              <div className="merge-content">
                <div className="section">
                  <h4>Content to merge:</h4>
                  <pre className="summary-preview">{summary}</pre>
                </div>

                {sourceNode.foundationMarkers?.length > 0 && (
                  <div className="section">
                    <h4>Foundations ({sourceNode.foundationMarkers.length}):</h4>
                    {sourceNode.foundationMarkers.map(idx => {
                      const msg = sourceNode.messages.filter(m => m.role !== 'system')[idx];
                      return msg ? (
                        <div key={idx} className="foundation-item">
                          â˜… {msg.text.slice(0, 80)}...
                        </div>
                      ) : null;
                    })}
                  </div>
                )}
              </div>

              <div className="merge-actions">
                <button className="secondary-btn" onClick={onCancel}>
                  Cancel
                </button>
                <button className="primary-btn" onClick={onConfirm}>
                  Confirm Merge
                </button>
              </div>
            </div>
          </div>
        );
      }

      // ============================================
      // UI COMPONENTS - Settings Modal
      // ============================================
      function SettingsModal({ apiKey, setApiKey, model, setModel, onClose }) {
        const [tempKey, setTempKey] = useState(apiKey);
        const [tempModel, setTempModel] = useState(model);

        const handleSave = () => {
          setApiKey(tempKey);
          setModel(tempModel);
          localStorage.setItem(STORAGE_KEY_API, tempKey);
          localStorage.setItem(STORAGE_KEY_MODEL, tempModel);
          onClose();
        };

        const handleClear = () => {
          setTempKey("");
          setApiKey("");
          localStorage.removeItem(STORAGE_KEY_API);
        };

        return (
          <div className="merge-preview-overlay" onClick={onClose}>
            <div className="merge-preview-modal settings-modal" onClick={e => e.stopPropagation()}>
              <div className="merge-header">
                <span className="ascii-arrow">âš™</span>
                Settings
              </div>

              <div className="merge-content">
                <div className="section">
                  <h4>Anthropic API Key</h4>
                  <p className="settings-hint">Get your API key from console.anthropic.com</p>
                  <input
                    type="password"
                    className="settings-input"
                    placeholder="sk-ant-..."
                    value={tempKey}
                    onChange={(e) => setTempKey(e.target.value)}
                  />
                  {tempKey && (
                    <button className="ghost-btn" onClick={handleClear} style={{marginTop: 8}}>
                      Clear key
                    </button>
                  )}
                </div>

                <div className="section">
                  <h4>Model</h4>
                  <div className="model-options">
                    {MODELS.map(m => (
                      <label key={m.id} className={`model-option ${tempModel === m.id ? 'selected' : ''}`}>
                        <input
                          type="radio"
                          name="model"
                          value={m.id}
                          checked={tempModel === m.id}
                          onChange={() => setTempModel(m.id)}
                        />
                        <div className="model-info">
                          <span className="model-name">{m.name}</span>
                          <span className="model-desc">{m.description}</span>
                        </div>
                      </label>
                    ))}
                  </div>
                </div>
              </div>

              <div className="merge-actions">
                <button className="secondary-btn" onClick={onClose}>
                  Cancel
                </button>
                <button className="primary-btn" onClick={handleSave}>
                  Save Settings
                </button>
              </div>
            </div>
          </div>
        );
      }

      // ============================================
      // MAIN APP
      // ============================================
      function App() {
        const [nodes, setNodes] = useState({
          root: createNode({
            id: "root",
            title: "Main Thread",
            messages: initialRootMessages,
            parentId: null
          }),
        });
        const [activeId, setActiveId] = useState("root");
        const [showPanel, setShowPanel] = useState(false);
        const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
        const [mergePreview, setMergePreview] = useState(null);

        // API and settings state
        const [apiKey, setApiKey] = useState(() => localStorage.getItem(STORAGE_KEY_API) || "");
        const [model, setModel] = useState(() => localStorage.getItem(STORAGE_KEY_MODEL) || MODELS[0].id);
        const [showSettings, setShowSettings] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        // Pending auto-send for forked nodes
        const [pendingSend, setPendingSend] = useState(null);
        const handleSendRef = useRef(null);

        // Effect to handle pending auto-sends when node becomes available
        useEffect(() => {
          if (pendingSend && nodes[pendingSend.id]) {
            const { id, text } = pendingSend;
            setPendingSend(null);
            // Small delay to ensure state is fully settled
            setTimeout(() => {
              handleSendRef.current(id, text);
            }, 50);
          }
        }, [pendingSend, nodes]);

        // Build enriched tree (supports multiple top-level threads)
        const trees = useMemo(() => {
          const childrenMap = {};
          const topLevelNodes = [];

          Object.values(nodes).forEach((node) => {
            if (node.parentId === null) {
              topLevelNodes.push(node);
            } else {
              childrenMap[node.parentId] = childrenMap[node.parentId] || [];
              childrenMap[node.parentId].push(node);
            }
          });

          const attach = (node, depth = 0) => {
            const enriched = {
              ...node,
              depth,
              children: (childrenMap[node.id] || [])
                .filter(child => child.status !== 'closed')
                .sort((a, b) => a.createdAt - b.createdAt)
                .map((child) => attach(child, depth + 1)),
            };
            return enriched;
          };

          return topLevelNodes
            .sort((a, b) => a.createdAt - b.createdAt)
            .map(node => attach(node, 0));
        }, [nodes]);

        // For backwards compatibility, also expose single tree
        const tree = trees[0] || null;

        // Calculate positions for canvas (handles multiple trees)
        const positions = useMemo(() => {
          const allPositions = {};
          let xOffset = 50;

          trees.forEach((t) => {
            if (!t) return;
            const treePositions = calculateTreeLayout(t);

            // Find the width of this tree
            let maxX = 0;
            Object.entries(treePositions).forEach(([id, pos]) => {
              maxX = Math.max(maxX, pos.x + NODE_WIDTH);
            });

            // Add positions with offset
            Object.entries(treePositions).forEach(([id, pos]) => {
              allPositions[id] = {
                ...pos,
                x: pos.x + xOffset - 100, // Adjust for the 100 starting offset in calculateTreeLayout
              };
            });

            xOffset += maxX + HORIZONTAL_GAP;
          });

          return allPositions;
        }, [trees]);

        // Flatten tree for lookups
        const flattenTree = (node, depth = 0) => {
          if (!node) return [];
          const current = { ...node, depth };
          const children = node.children || [];
          return [current, ...children.flatMap((child) => flattenTree(child, depth + 1))];
        };

        const nodesById = useMemo(() => {
          const list = trees.flatMap(t => flattenTree(t));
          return list.reduce((acc, n) => ({ ...acc, [n.id]: n }), {});
        }, [trees]);

        // Calculate max depth
        const maxDepth = useMemo(() => {
          let max = 0;
          const traverse = (node, depth = 0) => {
            if (!node) return;
            max = Math.max(max, depth);
            (node.children || []).forEach(child => traverse(child, depth + 1));
          };
          trees.forEach(t => traverse(t));
          return max;
        }, [trees]);

        // Current depth
        const currentDepth = nodesById[activeId]?.depth || 0;

        // Lineage for breadcrumbs
        const lineage = useMemo(() => {
          const path = [];
          let cursor = nodesById[activeId];
          while (cursor) {
            path.unshift(cursor);
            cursor = cursor.parentId ? nodesById[cursor.parentId] : null;
          }
          return path;
        }, [activeId, nodesById]);

        // Message handlers
        const addMessages = (id, newMessages) => {
          setNodes((prev) => ({
            ...prev,
            [id]: {
              ...prev[id],
              messages: [...prev[id].messages, ...newMessages],
            },
          }));
        };

        const simulateAssistant = (question, fromId) => {
          const parent = nodes[fromId];
          const context = parent.messages
            .slice(-3)
            .map((m) => `${m.role}: ${m.text}`)
            .join(" | ");
          return `Building on ${parent.title}'s context. ${context ? `Considering: "${context.slice(0, 100)}..."` : ''} Here's a thoughtful exploration of "${question}".`;
        };

        const handleSend = async (id, text) => {
          // Add user message immediately
          addMessages(id, [{ role: "user", text }]);

          if (!apiKey) {
            addMessages(id, [{
              role: "assistant",
              text: "Please add your Anthropic API key in Settings (âš™) to get AI responses."
            }]);
            setShowSettings(true);
            return;
          }

          setIsLoading(true);
          setError(null);

          // Add empty assistant message for streaming
          const streamingMsgIndex = nodes[id].messages.length + 1; // +1 for user msg we just added
          addMessages(id, [{ role: "assistant", text: "", isStreaming: true }]);

          try {
            const node = nodes[id];
            const conversationHistory = [...node.messages, { role: "user", text }];

            // Build system prompt with context about the conversation
            const depth = nodesById[id]?.depth || 0;
            const expertiseLevel = node.expertiseLevel;
            const isFirstMessage = node.messages.filter(m => m.role === 'user').length === 0;
            const isTopLevel = node.parentId === null;

            // Get parent context if this is a forked thread
            const systemMsg = node.messages.find(m => m.role === 'system');
            const parentContext = systemMsg?.parentContext || '';
            const immediateContext = systemMsg?.immediateContext || '';

            const expertiseContext = expertiseLevel
              ? `The user has indicated they are at expertise level ${expertiseLevel}/5 (1=complete novice, 5=expert).`
              : isTopLevel && isFirstMessage
                ? `This is the start of a new topic. Gauge their familiarity level before diving deep.`
                : '';

            const depthContext = depth > 0
              ? `Current exploration depth: ${depth}. The user has branched ${depth} level(s) deep into subtopics.`
              : '';

            const immediateContextSection = immediateContext
              ? `\n## IMPORTANT - The user selected this specific text to explore:\n"${immediateContext}"\n\nExplain the highlighted concept IN THIS CONTEXT. Don't give a generic definition - explain what it means in the specific situation described above.`
              : '';

            const parentContextSection = parentContext
              ? `\n## Background from parent conversation:\n${parentContext}\n\nBuild on this foundation - the user has already discussed the above.`
              : '';

            const systemPrompt = `You are a guide in Learnly, an exploration-first learning tool. Your job is to help users discover what interests them by offering clear, concise explanations with many paths to explore deeper.

## CRITICAL: Exploration Over Clarification
This tool works differently than typical AI interactions:
- Users learn by BRANCHING into subtopics, not by you asking clarifying questions
- Don't ask "what aspect interests you?" - instead, explain briefly and offer interesting branches
- The UI lets users click on ANY term to explore it - your job is to make concepts click-worthy
- Short, curiosity-sparking responses beat thorough explanations
- If unsure what they want, give a quick overview with MANY branch options - let them choose their path

## Depth-Aware Behavior:
${depth === 0 ? `- This is a TOP-LEVEL thread - user is likely still figuring out what they want to learn
- Keep responses SHORT (2-3 paragraphs max)
- Offer 4+ diverse branch suggestions spanning different aspects
- Don't ask what they already know - just start explaining accessibly` : ''}
${depth > 0 && depth <= 2 ? `- User has branched ${depth} level(s) deep - they're narrowing focus
- Give more detail than top-level, but still prioritize branches over exhaustive explanation
- 3-4 branch suggestions, more specific to this subtopic` : ''}
${depth > 2 ? `- User is ${depth} levels deep - they're clearly interested in detail here
- Can give more thorough explanations
- 2-3 very specific branch suggestions` : ''}

${expertiseContext}
${immediateContextSection}
${parentContextSection}

## Response Style:
- **Concise over comprehensive** - they can always branch for more
- Make terms and concepts INTERESTING so users want to click and explore them
- Use **bold** for key terms that would make good exploration branches
- Bullet points for listing related concepts
- NO clarifying questions like "what do you want to focus on?" - just provide content and branches

## IMPORTANT - End every response with this JSON block:

\`\`\`suggestions
{
  "title": "Short topic title (3-5 words)",
  "branches": ["Interesting Subtopic 1", "Interesting Subtopic 2", "Interesting Subtopic 3", "Interesting Subtopic 4"],
  "quick_answers": ["Tell me more", "How does this work?", "Why does this matter?"]
}
\`\`\`

- **title**: Concise title (3-5 words) capturing the topic. Update as focus becomes clearer.
- **branches**: ${depth === 0 ? '4-5' : depth <= 2 ? '3-4' : '2-3'} interesting subtopics to explore. Make them SPECIFIC and INTRIGUING - not generic. These become clickable fork buttons.
- **quick_answers**: 2-3 prompts that continue the conversation. Focus on "tell me more" style prompts, NOT clarifying questions back at the user.

Topic: "${node.title}"`;

            // Stream the response and update message progressively
            const fullResponse = await streamToClaudeAPI(
              conversationHistory,
              apiKey,
              model,
              systemPrompt,
              (partialText) => {
                // Update the streaming message with partial text
                setNodes(prev => {
                  const currentNode = prev[id];
                  const messages = [...currentNode.messages];
                  const lastMsg = messages[messages.length - 1];
                  if (lastMsg && lastMsg.isStreaming) {
                    messages[messages.length - 1] = {
                      ...lastMsg,
                      text: partialText
                    };
                  }
                  return {
                    ...prev,
                    [id]: { ...currentNode, messages }
                  };
                });
              }
            );

            // Parse the final response to extract suggestions
            const { cleanText, suggestions } = parseAIResponse(fullResponse);

            // Finalize the message with parsed content and suggestions
            setNodes(prev => {
              const currentNode = prev[id];
              const messages = [...currentNode.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg && lastMsg.isStreaming) {
                messages[messages.length - 1] = {
                  role: "assistant",
                  text: cleanText,
                  suggestions: suggestions,
                  isStreaming: false
                };
              }

              // Update title if AI suggested one
              const newTitle = suggestions.title || currentNode.title;

              return {
                ...prev,
                [id]: { ...currentNode, messages, title: newTitle }
              };
            });

          } catch (err) {
            console.error("API Error:", err);
            setError(err.message);
            // Update the streaming message with error
            setNodes(prev => {
              const currentNode = prev[id];
              const messages = [...currentNode.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg && lastMsg.isStreaming) {
                messages[messages.length - 1] = {
                  role: "assistant",
                  text: `Error: ${err.message}\n\nPlease check your API key in Settings.`,
                  isStreaming: false
                };
              }
              return {
                ...prev,
                [id]: { ...currentNode, messages }
              };
            });
          } finally {
            setIsLoading(false);
          }
        };

        // Keep ref updated for useEffect
        handleSendRef.current = handleSend;

        const makeTitle = (parentTitle, selection) => {
          if (selection) {
            const trimmed = selection.slice(0, 28);
            return `${trimmed}${selection.length > 28 ? "..." : ""}`;
          }
          return `${parentTitle} fork`;
        };

        // Compress parent thread context for passing to child fork
        const compressContext = (node) => {
          const msgs = node.messages.filter(m => m.role !== 'system');
          if (msgs.length === 0) return '';

          // Get key exchanges (last few Q&A pairs)
          const exchanges = [];
          for (let i = 0; i < msgs.length - 1; i++) {
            if (msgs[i].role === 'user' && msgs[i + 1].role === 'assistant') {
              exchanges.push({
                q: msgs[i].text.slice(0, 100),
                a: msgs[i + 1].text.slice(0, 200)
              });
            }
          }

          // Take last 2-3 exchanges
          const recent = exchanges.slice(-3);
          if (recent.length === 0) return '';

          return recent.map(ex => `Q: ${ex.q}\nA: ${ex.a}`).join('\n\n');
        };

        const handleFork = async (fromId, explicitSelection, autoSend = false, immediateContext = null) => {
          const base = nodes[fromId];
          const picked = (explicitSelection && explicitSelection.trim()) || selectionText();
          const contextSnippet = picked || base.messages.slice(-1).map((m) => m.text).join(" ").slice(0, 50);
          const id = `node-${Date.now()}-${Math.round(Math.random() * 9999)}`;

          // Compress context from parent for the fork
          const parentContext = compressContext(base);

          // Create the new node
          const newNode = createNode({
            id,
            parentId: fromId,
            title: makeTitle(base.title, contextSnippet),
            expertiseLevel: base.expertiseLevel, // Inherit expertise from parent
            messages: [
              {
                role: "system",
                origin: base.title,
                text: `Forked from "${base.title}" to explore: ${contextSnippet || "new direction"}`,
                parentContext: parentContext,
                immediateContext: immediateContext, // The sentence/paragraph where the term appeared
              },
            ],
          });

          setNodes((prev) => ({ ...prev, [id]: newNode }));
          setActiveId(id);
          setShowPanel(true);

          // If autoSend, queue up the send for when node is available
          if (autoSend && picked) {
            const contextualRequest = immediateContext
              ? `Explain "${picked}" in this context: ${immediateContext}`
              : `I want to explore: ${picked}`;
            setPendingSend({ id, text: contextualRequest });
          }
        };

        const handleNewChat = () => {
          const id = `node-${Date.now()}-${Math.round(Math.random() * 9999)}`;
          const topLevelCount = Object.values(nodes).filter((n) => n.parentId === null).length;

          const newNode = createNode({
            id,
            parentId: null, // Top-level thread (sibling of root)
            title: `Thread ${topLevelCount + 1}`,
            messages: [{ role: "assistant", text: "New exploration thread started. What would you like to learn about?" }],
          });

          setNodes((prev) => ({ ...prev, [id]: newNode }));
          setActiveId(id);
          setShowPanel(true);
        };

        const handleToggleFoundation = (nodeId, messageIndex) => {
          setNodes(prev => {
            const node = prev[nodeId];
            const isMarked = node.foundationMarkers.includes(messageIndex);
            const newMarkers = isMarked
              ? node.foundationMarkers.filter(i => i !== messageIndex)
              : [...node.foundationMarkers, messageIndex];

            const updatedNode = {
              ...node,
              foundationMarkers: newMarkers,
            };
            updatedNode.health = calculateHealth(updatedNode);

            return { ...prev, [nodeId]: updatedNode };
          });
        };

        const handleSetExpertise = (nodeId, level) => {
          setNodes(prev => ({
            ...prev,
            [nodeId]: {
              ...prev[nodeId],
              expertiseLevel: level,
            }
          }));
        };

        const handleCloseWithMerge = (id) => {
          const node = nodes[id];
          const targetId = node.parentId || 'root';
          setMergePreview({ sourceId: id, targetId });
        };

        const confirmMerge = () => {
          if (!mergePreview) return;

          const { sourceId, targetId } = mergePreview;
          const sourceNode = nodes[sourceId];
          const targetNode = nodes[targetId];

          const summary = summarizeMessages(sourceNode.messages, sourceNode.foundationMarkers);

          setNodes((prev) => ({
            ...prev,
            [targetId]: {
              ...targetNode,
              messages: [
                ...targetNode.messages,
                {
                  role: "assistant",
                  origin: sourceNode.title,
                  mergedFrom: {
                    branchId: sourceId,
                    branchTitle: sourceNode.title,
                    timestamp: Date.now(),
                    foundationCount: sourceNode.foundationMarkers.length,
                  },
                  text: `Merged insights from "${sourceNode.title}":\n\n${summary}`,
                },
              ],
              mergeHistory: [...(targetNode.mergeHistory || []), {
                branchId: sourceId,
                branchTitle: sourceNode.title,
                timestamp: Date.now(),
              }],
            },
            [sourceId]: { ...sourceNode, status: "closed" },
          }));

          setMergePreview(null);
          setActiveId(targetId);
        };

        const selectNode = (id) => {
          setActiveId(id);
          setShowPanel(true);
        };

        const closePanel = () => {
          setShowPanel(false);
        };

        return (
          <div className="app-shell">
            <Sidebar
              trees={trees}
              activeId={activeId}
              onSelect={selectNode}
              onNewChat={handleNewChat}
              currentDepth={currentDepth}
              maxDepth={maxDepth}
              onJumpTo={selectNode}
              onOpenSettings={() => setShowSettings(true)}
              hasApiKey={!!apiKey}
            />

            <div className="main-area">
              <TreeCanvas
                trees={trees}
                activeId={activeId}
                onSelect={selectNode}
                positions={positions}
                transform={transform}
                onTransformChange={setTransform}
                onNewThread={handleNewChat}
              />

              {showPanel && (
                <NodePanel
                  node={nodesById[activeId]}
                  onClose={closePanel}
                  onSend={handleSend}
                  onFork={handleFork}
                  onToggleFoundation={handleToggleFoundation}
                  onCloseWithMerge={handleCloseWithMerge}
                  lineage={lineage}
                  onJump={selectNode}
                  isLoading={isLoading}
                  onSetExpertise={handleSetExpertise}
                />
              )}
            </div>

            {mergePreview && (
              <MergePreview
                sourceNode={nodes[mergePreview.sourceId]}
                targetNode={nodes[mergePreview.targetId]}
                onConfirm={confirmMerge}
                onCancel={() => setMergePreview(null)}
              />
            )}

            {showSettings && (
              <SettingsModal
                apiKey={apiKey}
                setApiKey={setApiKey}
                model={model}
                setModel={setModel}
                onClose={() => setShowSettings(false)}
              />
            )}
          </div>
        );
      }

      // ============================================
      // RENDER
      // ============================================
      const container = document.getElementById("root");
      const root = ReactDOM.createRoot(container);
      root.render(<App />);
    </script>
  </body>
</html>
